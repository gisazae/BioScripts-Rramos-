<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Hidden Markov Models &mdash; Bioinformatics 0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/badge_only.css" type="text/css" />
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
    <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>
    <link rel="top" title="Bioinformatics 0.1 documentation" href="https://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/index.html" />
    <link rel="next" title="Answers to the End-of-chapter Exercises" href="chapter_answers.html" />
    <link rel="prev" title="Comparative Genomics" href="chapter9.html" />
 
<!-- RTD Extra Head -->



<!-- 
Read the Docs is acting as the canonical URL for your project. 
If you want to change it, more info is available in our docs:
  http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/src/chapter10.html" />

<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "a-little-book-of-r-for-bioinformatics",
    version: "latest",
    language: "en",
    page: "src/chapter10",
    builder: "sphinx",
    theme: "sphinxdoc",
    docroot: "/",
    source_suffix: ".rst",
    api_host: "https://readthedocs.org",
    commit: "8cd107b180ed964fe7c8021e78ff0ab528d5ba74"
  }
  // Old variables
  var doc_version = "latest";
  var doc_slug = "a-little-book-of-r-for-bioinformatics";
  var page_name = "src/chapter10";
  var html_theme = "sphinxdoc";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  // User Analytics Code
  _gaq.push(['user._setAccount', 'UA-36029021-1']);
  _gaq.push(['user._trackPageview']);
  // End User Analytics Code


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chapter_answers.html" title="Answers to the End-of-chapter Exercises"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chapter9.html" title="Comparative Genomics"
             accesskey="P">previous</a> |</li>
        <li><a href="https://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/index.html">Bioinformatics 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="https://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="chapter10.html#">Hidden Markov Models</a><ul>
<li><a class="reference internal" href="chapter10.html#a-little-more-about-r">A little more about R</a></li>
<li><a class="reference internal" href="chapter10.html#a-multinomial-model-of-dna-sequence-evolution">A multinomial model of DNA sequence evolution</a></li>
<li><a class="reference internal" href="chapter10.html#generating-a-dna-sequence-using-a-multinomial-model">Generating a DNA sequence using a multinomial model</a></li>
<li><a class="reference internal" href="chapter10.html#a-markov-model-of-dna-sequence-evolution">A Markov model of DNA sequence evolution</a></li>
<li><a class="reference internal" href="chapter10.html#the-transition-matrix-for-a-markov-model">The transition matrix for a Markov model</a></li>
<li><a class="reference internal" href="chapter10.html#generating-a-dna-sequence-using-a-markov-model">Generating a DNA sequence using a Markov model</a></li>
<li><a class="reference internal" href="chapter10.html#a-hidden-markov-model-of-dna-sequence-evolution">A Hidden Markov Model of DNA sequence evolution</a></li>
<li><a class="reference internal" href="chapter10.html#the-transition-matrix-and-emission-matrix-for-a-hmm">The transition matrix and emission matrix for a HMM</a></li>
<li><a class="reference internal" href="chapter10.html#generating-a-dna-sequence-using-a-hmm">Generating a DNA sequence using a HMM</a></li>
<li><a class="reference internal" href="chapter10.html#inferring-the-states-of-a-hmm-that-generated-a-dna-sequence">Inferring the states of a HMM that generated a DNA sequence</a></li>
<li><a class="reference internal" href="chapter10.html#a-hidden-markov-model-of-protein-sequence-evolution">A Hidden Markov Model of protein sequence evolution</a></li>
<li><a class="reference internal" href="chapter10.html#summary">Summary</a></li>
<li><a class="reference internal" href="chapter10.html#links-and-further-reading">Links and Further Reading</a></li>
<li><a class="reference internal" href="chapter10.html#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="chapter10.html#exercises">Exercises</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chapter9.html"
                        title="previous chapter">Comparative Genomics</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chapter_answers.html"
                        title="next chapter">Answers to the End-of-chapter Exercises</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="https://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/_sources/src/chapter10.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="https://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="hidden-markov-models">
<h1>Hidden Markov Models<a class="headerlink" href="chapter10.html#hidden-markov-models" title="Permalink to this headline">¶</a></h1>
<div class="section" id="a-little-more-about-r">
<h2>A little more about R<a class="headerlink" href="chapter10.html#a-little-more-about-r" title="Permalink to this headline">¶</a></h2>
<p>In previous practicals, you learnt how to create different types of
variables in R such as scalars, vectors and lists. Sometimes it is
useful to create a variable before you actually need to store any
data in the variable. To create a vector without actually storing
any data in it, you can use the numeric() command to create a
vector for storing numbers, or the character() command to create a
vector for storing characters (eg. &#8220;A&#8221;, &#8220;hello&#8221;, etc.) For example,
you may want to create a vector variable for storing the square of
a number, and then store numbers in its elements afterwards:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; myvector &lt;- numeric()                  # Create a vector &quot;myvector&quot; for storing numbers
&gt; for (i in 1:10) { myvector[i] &lt;- i*i } # Fill in the values in the vector &quot;myvector&quot;
&gt; myvector                               # Print out the vector &quot;myvector&quot;
[1]   1   4   9  16  25  36  49  64  81 100
</pre></div>
</div>
<p>Note that if you try to store numbers in the elements of a vector
that you have not yet created, you will get an error message, for
example:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; for (i in 1:10) { avector[i] &lt;- i*i }  # Try to store values in the vector &quot;avector&quot;
Error in avector[i] &lt;- i * i : object &#39;avector&#39; not found
</pre></div>
</div>
<p>Another very useful type of variable is a matrix. You can create a
matrix in R using the matrix() command. If you look at the help
page for the matrix() command, you will see that its arguments
(inputs) are the data to store in the matrix, the number of rows to
store it in, the number of columns to store it in, and whether to
fill the matrix with data column-by-column or row-by-row. For
example, say you have the heights and weights of eight patients in
a hospital in two different vectors:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; heights &lt;- c(180, 170, 175, 160, 183, 177, 179, 182)
&gt; weights &lt;- c(90, 88, 100, 68, 95, 120, 88, 93)
</pre></div>
</div>
<p>To store this data in a matrix that has one column per person, and
one row for heights and one row for weights, we type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; mymatrix &lt;- matrix(c(heights,weights), 2, 8, byrow=TRUE)
&gt; mymatrix # Print out the matrix
[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]  180  170  175  160  183  177  179  182
[2,]   90   88  100   68   95  120   88   93
</pre></div>
</div>
<p>We needed to use the argument &#8220;byrow=TRUE&#8221; to tell the matrix()
command to fill the matrix row-by-row (ie. to put the values from
the vector <em>heights</em> into the first row of the matrix, and the
values from the vector <em>weights</em> into the second row of the
matrix).</p>
<p>You can assign names to the rows and columns of a matrix using the
rownames() and colnames() commands, respectively. For example, to
assign names to the rows and columns of matrix <em>mymatrix</em>, you
could type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; rownames(mymatrix) &lt;- c(&quot;height&quot;, &quot;weight&quot;)
&gt; colnames(mymatrix) &lt;- c(&quot;patient1&quot;, &quot;patient2&quot;, &quot;patient3&quot;, &quot;patient4&quot;, &quot;patient5&quot;, &quot;patient6&quot;, &quot;patient7&quot;, &quot;patient8&quot;)
&gt; mymatrix # Print out the matrix now
patient1 patient2 patient3 patient4 patient5 patient6 patient7 patient8
height      180      170      175      160      183      177      179      182
weight       90       88      100       68       95      120       88       93
</pre></div>
</div>
<p>Once you have created a matrix, you can access the values in the
elements of the matrix by using square brackets containing the
indices of the row and column of the element. For example, if you
want to access the value in the second row and fourth column of
matrix <em>mymatrix</em>, you can type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; mymatrix[2,4]
[1] 68
</pre></div>
</div>
<p>If you want to access all the values in a particular row of the
matrix, you can just type the index for the row, and leave out the
index for the column. For example, if you want to get the values in
the second row of the matrix <em>mymatrix</em>, type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; mymatrix[2,]
patient1 patient2 patient3 patient4 patient5 patient6 patient7 patient8
90       88      100       68       95      120       88       93
</pre></div>
</div>
<p>Likewise, if you want to get the values in a particular column of a
matrix, leave out the index for the row, and just type the column
index. For example, if you want to get the values in the fourth row
of the <em>mymatrix</em>, type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; mymatrix[,4]
height weight
160     68
</pre></div>
</div>
</div>
<div class="section" id="a-multinomial-model-of-dna-sequence-evolution">
<h2>A multinomial model of DNA sequence evolution<a class="headerlink" href="chapter10.html#a-multinomial-model-of-dna-sequence-evolution" title="Permalink to this headline">¶</a></h2>
<p>The simplest model of DNA sequence evolution assumes that the
sequence has been produced by a random process that randomly chose
any of the four nucleotides at each position in the sequence, where
the probability of choosing any one of the four nucleotides depends
on a predetermined probability distribution. That is, the four
nucleotides are chosen with p<sub>A</sub>, p<sub>C</sub>,
p<sub>G</sub>, and p<sub>T</sub> respectively. This is known as
the <em>multinomial sequence model</em>.</p>
<p>A multinomial model for DNA sequence evolution has four parameters:
the probabilities of the four nucleotides p<sub>A</sub>,
p<sub>C</sub>, p<sub>G</sub>, and p<sub>T</sub>. For example,
say we may create a multinomial model where p<sub>A</sub>=0.2,
p<sub>C</sub>=0.3, p<sub>G</sub>=0.3, and p<sub>T</sub>=0.2.
This means that the probability of choosing a A at any particular
sequence position is set to be 0.2, the probability of choosing a C
is 0.3, of choosing a G is 0.3, and of choosing a T is 0.2. Note
that p<sub>A</sub> + p<sub>C</sub> + p<sub>G</sub> +
p<sub>T</sub> = 1, as the sum of the probabilities of the four
different types of nucleotides must be equal to 1, as there are
only four possible types of nucleotide.</p>
<p>The multinomial sequence model is like having a roulette wheel that
is divided into four different slices labelled &#8220;A&#8221;, &#8220;T&#8221;, &#8220;G&#8221; and
&#8220;C&#8221;, where the p<sub>A</sub>, p<sub>T</sub>, p<sub>G</sub>and p<sub>C</sub> are the fractions of the wheel taken up by the
slices with these four labels. If you spin the arrow attached to
the centre of the roulette wheel, the probability that it will stop
in the slice with a particular label (eg. the slice labelled &#8220;A&#8221;)
only depends on the fraction of the wheel taken up by that slice
(p<sub>A</sub> here; see the picture below).</p>
<p><a class="reference internal" href="../_images/P10_image4.png"><img alt="image0" src="../_images/P10_image4.png" style="width: 500px;" /></a></p>
</div>
<div class="section" id="generating-a-dna-sequence-using-a-multinomial-model">
<h2>Generating a DNA sequence using a multinomial model<a class="headerlink" href="chapter10.html#generating-a-dna-sequence-using-a-multinomial-model" title="Permalink to this headline">¶</a></h2>
<p>We can use R to generate a DNA sequence using a particular
multinomial model. First we need to set the values of the four
parameters of the multinomial model, the probabilities
p<sub>A</sub>, p<sub>C</sub>, p<sub>G</sub>, and
p<sub>T</sub> of choosing the nucleotides A, C, G and T,
respectively, at a particular position in the DNA sequence. For
example, say we decide to set p<sub>A</sub>=0.2,
p<sub>C</sub>=0.3, p<sub>G</sub>=0.3, and p<sub>T</sub>=0.2.
We can use the function sample() in R to generate a DNA sequence of
a certain length, by selecting a nucleotide at each position
according to this probability distribution:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; nucleotides    &lt;- c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) # Define the alphabet of nucleotides
&gt; probabilities1 &lt;- c(0.2, 0.3, 0.3, 0.2) # Set the values of the probabilities
&gt; seqlength      &lt;- 30                    # Set the length of the sequence
&gt; sample(nucleotides, seqlength, rep=TRUE, prob=probabilities1) # Generate a sequence
[1] &quot;A&quot; &quot;C&quot; &quot;T&quot; &quot;G&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;A&quot; &quot;G&quot; &quot;T&quot; &quot;C&quot; &quot;A&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;C&quot; &quot;G&quot;
[20] &quot;C&quot; &quot;G&quot; &quot;T&quot; &quot;C&quot; &quot;C&quot; &quot;G&quot; &quot;G&quot; &quot;C&quot; &quot;A&quot; &quot;G&quot; &quot;C&quot;
</pre></div>
</div>
<p>If you look at the help page for the function(), you will find that
its inputs are the vector to sample from (<em>nucleotides</em> here), the
size of the sample (<em>seqlength</em> here), and a vector of
probabilities for obtaining the elements of the vector being
sampled (<em>probabilities1</em> here). If we use the sample() function to
generate a sequence again, it will create a different sequence
using the same multinomial model:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; sample(nucleotides, seqlength, rep=TRUE, prob=probabilities1) # Generate another sequence
[1] &quot;T&quot; &quot;G&quot; &quot;C&quot; &quot;T&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;G&quot; &quot;T&quot; &quot;C&quot; &quot;G&quot; &quot;A&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;C&quot;
[20] &quot;T&quot; &quot;A&quot; &quot;A&quot; &quot;C&quot; &quot;C&quot; &quot;G&quot; &quot;A&quot; &quot;G&quot; &quot;G&quot; &quot;C&quot; &quot;G&quot;
</pre></div>
</div>
<p>In the same way, we can generate a sequence using a different
multinomial model, where p<sub>A</sub>=0.1, p<sub>C</sub>=0.41,
p<sub>G</sub>=0.39, and p<sub>T</sub>=0.1:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; probabilities2 &lt;- c(0.1, 0.41, 0.39, 0.1) # Set the values of the probabilities for the new model
&gt; sample(nucleotides, seqlength, rep=TRUE, prob=probabilities2) # Generate a sequence
[1] &quot;G&quot; &quot;C&quot; &quot;C&quot; &quot;T&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;A&quot; &quot;G&quot;
[20] &quot;A&quot; &quot;G&quot; &quot;C&quot; &quot;T&quot; &quot;C&quot; &quot;G&quot; &quot;G&quot; &quot;C&quot; &quot;G&quot; &quot;G&quot; &quot;C&quot;
</pre></div>
</div>
<p>As you would expect, the sequences generated using this second
multinomial model have a higher fraction of Cs and Gs compared to
the sequences generated using the first multinomial model above.
This is because p<sub>C</sub> and G<sub>T</sub> are higher for
this second model than for the first model (p<sub>C</sub>=0.41
and G<sub>T</sub>=0.39 in the second model, versus
p<sub>C</sub>=0.3 and G<sub>T</sub>=0.3 in the first model).
That is, in the second multinomial model we are using a roulette
wheel that has large slices labelled &#8220;C&#8221; and &#8220;G&#8221;, while in the
first multinomial model we were using a roulette wheel with
relatively smaller slices labelled &#8220;C&#8221; and &#8220;G&#8221; (see the picture
below).</p>
<p><a class="reference internal" href="../_images/P10_image3.png"><img alt="image1" src="../_images/P10_image3.png" style="width: 500px;" /></a></p>
</div>
<div class="section" id="a-markov-model-of-dna-sequence-evolution">
<h2>A Markov model of DNA sequence evolution<a class="headerlink" href="chapter10.html#a-markov-model-of-dna-sequence-evolution" title="Permalink to this headline">¶</a></h2>
<p>A multinomial model of DNA sequence evolution is a good model of
the evolution of many DNA sequences. However, for some DNA
sequences, a multinomial model is not an accurate representation of
how the sequences have evolved. One reason is that a multinomial
model assumes that each part of the sequence (eg. the first 100
nucleotides of the sequence, the second 100 nucleotides, the third
100 nucleotides, etc.) have the same frequency of each type of
nucleotide (the same p<sub>A</sub>, p<sub>C</sub>,
p<sub>G</sub>, and p<sub>T</sub>), and this may not be true for
a particular DNA sequence if there are considerable differences in
nucleotide frequencies in different parts of the sequence.</p>
<p>Another assumption of a multinomial model of DNA sequence evolution
is that the probability of choosing a particular nucleotide (eg.
&#8220;A&#8221;) at a particular position in the sequence only depends on the
predetermined frequency of that nucleotide (p<sub>A</sub> here),
and does not depend at all on the nucleotides found at adjacent
positions in the sequence. This assumption holds true for many DNA
sequences. However, for some DNA sequences, it is not true, because
the probability of finding a particular nucleotide at a particular
position in the sequence <em>does</em> depend on what nucleotides are
found at adjacent positions in the sequence. In this case, a
different type of DNA sequence model called a
<em>Markov sequence model</em> is a more accurate representation of the
evolution of the sequence.</p>
<p>A Markov sequence model assumes that the sequence has been produced
by a process that chose any of the four nucleotides in the
sequence, where the probability of choosing any one of the four
nucleotides at a particular position depends on the nucleotide
chosen for the previous position. That is, if &#8220;A&#8221; was chosen at the
previous position, then the probability of choosing any one of the
four nucleotides at the current position depends on a predetermined
probability distribution. That is, given that &#8220;A&#8221; was chosen at the
previous position, the four nucleotides are chosen at the current
position with probabilities of p<sub>A</sub>, p<sub>C</sub>,
p<sub>G</sub>, and p<sub>T</sub> of choosing &#8220;A&#8221;, &#8220;C&#8221;, &#8220;G&#8221;, or
&#8220;T&#8221;, respectively (eg. p<sub>A</sub>=0.2, p<sub>C</sub>=0.3,
p<sub>G</sub>=0.3, and p<sub>T</sub>=0.2). In contrast, if &#8220;C&#8221;
was chosen at the previous position, then the probability of
choosing any one of the four nucleotides at the current position
depends on a different predetermined probability distribution, that
is, the probabilities of choosing &#8220;A&#8221;, &#8220;C&#8221;, &#8220;G&#8221;, or &#8220;T&#8221; at the
current position are now different (eg. p<sub>A</sub>=0.1,
p<sub>C</sub>=0.41, p<sub>G</sub>=0.39, and
p<sub>T</sub>=0.1).</p>
<p>A Markov sequence model is like having four different roulette
wheels, labelled &#8220;afterA&#8221;, &#8220;afterT&#8221;, &#8220;afterG&#8221;, and &#8220;afterC&#8221;, for
the cases when &#8220;A&#8221;, &#8220;T&#8221;, &#8220;G&#8221;, or &#8220;C&#8221; were chosen at the previous
position in a sequence, respectively. Each of the four roulette
wheels has four slices labelled &#8220;A&#8221;, &#8220;T&#8221;, &#8220;G&#8221;, and &#8220;C&#8221;, but in each
roulette wheel a different fraction of the wheel is taken up by the
four slices. That is, each roulette wheel has a different
p<sub>A</sub>, p<sub>T</sub>, p<sub>G</sub> and
p<sub>C</sub>. If we are generating a new DNA sequence using a
Markov sequence model, to decide what nucleotide to choose at a
particular position in the sequence, you spin the arrow at the
centre of a roulette wheel, and see in which slice the arrow stops.
There are four roulette wheels, and the particular roulette wheel
we use at a particular position in the sequence depends on the
nucleotide chosen for the previous position in the sequence. For
example, if &#8220;T&#8221; was chosen at the previous position, we use the
&#8220;afterT&#8221; roulette wheel to choose the nucleotide for the current
position. The probability of choosing a particular nucleotide at
the current position (eg. &#8220;A&#8221;) then depends on the fraction of the
&#8220;afterT&#8221; roulette wheel taken up by the the slice labelled with
that nucleotide (p<sub>A</sub> here; see the picture below).</p>
<p><a class="reference internal" href="../_images/P10_image5.png"><img alt="image2" src="../_images/P10_image5.png" style="width: 500px;" /></a></p>
</div>
<div class="section" id="the-transition-matrix-for-a-markov-model">
<h2>The transition matrix for a Markov model<a class="headerlink" href="chapter10.html#the-transition-matrix-for-a-markov-model" title="Permalink to this headline">¶</a></h2>
<p>A multinomial model of DNA sequence evolution just has four
parameters: the probabilities p<sub>A</sub>, p<sub>C</sub>,
p<sub>G</sub>, and p<sub>T</sub>. In contrast, a Markov model
has many more parameters: four sets of probabilities
p<sub>A</sub>, p<sub>C</sub>, p<sub>G</sub>, and
p<sub>T</sub>, that differ according to whether the previous
nucleotide was &#8220;A&#8221;, &#8220;G&#8221;, &#8220;T&#8221; or &#8220;C&#8221;. The symbols p<sub>AA</sub>,
p<sub>AC</sub>, p<sub>AG</sub>, and p<sub>AT</sub> are
usually used to represent the four probabilities for the case where
the previous nucleotide was &#8220;A&#8221;, the symbols p<sub>CA</sub>,
p<sub>CC</sub>, p<sub>CG</sub>, and p<sub>CT</sub> for the
case when the previous nucleotide was &#8220;C&#8221;, and so on.</p>
<p>It is common to store the probability parameters for a Markov model
of a DNA sequence in a square matrix, which is known as a
<em>Markov transition matrix</em>. The rows of the transition matrix
represent the nucleotide found at the previous position in the
sequence, while the columns represent the nucleotides that could be
found at the current position in the sequence. In R, you can create
a matrix using the matrix() command, and the rownames() and
colnames() functions can be used to label the rows and columns of
the matrix. For example, to create a transition matrix, we type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; nucleotides         &lt;- c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) # Define the alphabet of nucleotides
&gt; afterAprobs &lt;- c(0.2, 0.3, 0.3, 0.2)         # Set the values of the probabilities, where the previous nucleotide was &quot;A&quot;
&gt; afterCprobs &lt;- c(0.1, 0.41, 0.39, 0.1)       # Set the values of the probabilities, where the previous nucleotide was &quot;C&quot;
&gt; afterGprobs &lt;- c(0.25, 0.25, 0.25, 0.25)     # Set the values of the probabilities, where the previous nucleotide was &quot;G&quot;
&gt; afterTprobs &lt;- c(0.5, 0.17, 0.17, 0.17)      # Set the values of the probabilities, where the previous nucleotide was &quot;T&quot;
&gt; mytransitionmatrix &lt;- matrix(c(afterAprobs, afterCprobs, afterGprobs, afterTprobs), 4, 4, byrow = TRUE) # Create a 4 x 4 matrix
&gt; rownames(mytransitionmatrix) &lt;- nucleotides
&gt; colnames(mytransitionmatrix) &lt;- nucleotides
&gt; mytransitionmatrix                           # Print out the transition matrix
A    C    G    T
A 0.20 0.30 0.30 0.20
C 0.10 0.41 0.39 0.10
G 0.25 0.25 0.25 0.25
T 0.50 0.17 0.17 0.17
</pre></div>
</div>
<p>Rows 1, 2, 3 and 4 of the transition matrix give the probabilities
p<sub>A</sub>, p<sub>C</sub>, p<sub>G</sub>, and
p<sub>T</sub> for the cases where the previous nucleotide was
&#8220;A&#8221;, &#8220;C&#8221;, &#8220;G&#8221;, or &#8220;T&#8221;, respectively. That is, the element in a
particular row and column of the transition matrix (eg. the row for
&#8220;A&#8221;, column for &#8220;C&#8221;) holds the probability (p<sub>AC</sub>) of
choosing a particular nucleotide (&#8220;C&#8221;) at the current position in
the sequence, given that was a particular nucleotide (&#8220;A&#8221;) at the
previous position in the sequence.</p>
</div>
<div class="section" id="generating-a-dna-sequence-using-a-markov-model">
<h2>Generating a DNA sequence using a Markov model<a class="headerlink" href="chapter10.html#generating-a-dna-sequence-using-a-markov-model" title="Permalink to this headline">¶</a></h2>
<p>Just as you can generate a DNA sequence using a particular
multinomial model, you can generate a DNA sequence using a
particular Markov model. When you are generating a DNA sequence
using a Markov model, the nucleotide chosen at each position at the
sequence depends on the nucleotide chosen at the previous position.
As there is no previous nucleotide at the first position in the new
sequence, we need to define the probabilities of choosing &#8220;A&#8221;, &#8220;C&#8221;,
&#8220;G&#8221; or &#8220;T&#8221; for the first position. The symbols Π<sub>A</sub>,
Π<sub>C</sub>, Π<sub>G</sub>, and Π<sub>T</sub> are used to
represent the probabilities of choosing &#8220;A&#8221;, &#8220;C&#8221;, &#8220;G&#8221;, or &#8220;T&#8221; at
the first position.</p>
<p>We can define an R function generatemarkovseq() to generate a DNA
sequence using a particular Markov model:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; generatemarkovseq &lt;- function(transitionmatrix, initialprobs, seqlength)
{
nucleotides     &lt;- c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) # Define the alphabet of nucleotides
mysequence      &lt;- character()           # Create a vector for storing the new sequence
# Choose the nucleotide for the first position in the sequence:
firstnucleotide &lt;- sample(nucleotides, 1, rep=TRUE, prob=initialprobs)
mysequence[1]   &lt;- firstnucleotide       # Store the nucleotide for the first position of the sequence
for (i in 2:seqlength)
{
prevnucleotide &lt;- mysequence[i-1]     # Get the previous nucleotide in the new sequence
# Get the probabilities of the current nucleotide, given previous nucleotide &quot;prevnucleotide&quot;:
probabilities  &lt;- transitionmatrix[prevnucleotide,]
# Choose the nucleotide at the current position of the sequence:
nucleotide     &lt;- sample(nucleotides, 1, rep=TRUE, prob=probabilities)
mysequence[i]  &lt;- nucleotide          # Store the nucleotide for the current position of the sequence
}
return(mysequence)
}
</pre></div>
</div>
<p>The function generatemarkovseq() takes as its arguments (inputs)
the transition matrix for the particular Markov model; a vector
containing the values of Π<sub>A</sub>, Π<sub>C</sub>,
Π<sub>G</sub>, and Π<sub>T</sub>; and the length of the DNA
sequence to be generated.</p>
<p>The probabilities of choosing each of the four nucleotides at the
first position in the sequence are Π<sub>A</sub>,
Π<sub>C</sub>, Π<sub>G</sub>, and Π<sub>T</sub>. The
probabilities of choosing each of the four nucleotides at the
second position in the sequence depend on the particular nucleotide
that was chosen at the first position in the sequence. The
probabilities of choosing each of the four nucleotides at the third
position depend on the nucleotide chosen at the second position,
and so on.</p>
<p>We can use the generatemarkovseq() function to generate a sequence
using a particular Markov model. For example, to create a sequence
of 30 nucleotides using the Markov model described in the
transition matrix <em>mytransitionmatrix</em>, using uniform starting
probabilities (ie. Π<sub>A</sub> = 0.25, Π<sub>C</sub> = 0.25,
Π<sub>G</sub> = 0.25, and Π<sub>T</sub> = 0.25) , we type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; myinitialprobs &lt;- c(0.25, 0.25, 0.25, 0.25)
&gt; generatemarkovseq(mytransitionmatrix, myinitialprobs, 30)
[1] &quot;A&quot; &quot;T&quot; &quot;C&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;A&quot; &quot;T&quot; &quot;A&quot; &quot;T&quot; &quot;A&quot; &quot;T&quot; &quot;A&quot; &quot;G&quot; &quot;C&quot; &quot;G&quot; &quot;C&quot; &quot;T&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;G&quot;
[24] &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;T&quot; &quot;C&quot;
</pre></div>
</div>
<p>As you can see, there are many &#8220;A&#8221;s after &#8220;T&#8221;s in the sequence.
This is because p<sub>TA</sub> has a high value (0.5) in the
Markov transition matrix <em>mytransitionmatrix</em>. Similarly, there are
few &#8220;A&#8221;s or &#8220;T&#8221;s after &#8220;C&#8221;s, which is because p<sub>CA</sub> and
p<sub>CT</sub> have low values (0.1) in this transition matrix.</p>
</div>
<div class="section" id="a-hidden-markov-model-of-dna-sequence-evolution">
<h2>A Hidden Markov Model of DNA sequence evolution<a class="headerlink" href="chapter10.html#a-hidden-markov-model-of-dna-sequence-evolution" title="Permalink to this headline">¶</a></h2>
<p>In a Markov model, the nucleotide at a particular position in a
sequence depends on the nucleotide found at the previous position.
In contrast, in a <em>Hidden Markov model</em> (HMM), the nucleotide found
at a particular position in a sequence depends on the <em>state</em> at
the previous nucleotide position in the sequence. The <em>state</em> at a
sequence position is a property of that position of the sequence,
for example, a particular HMM may model the positions along a
sequence as belonging to either one of two states, &#8220;GC-rich&#8221; or
&#8220;AT-rich&#8221;. A more complex HMM may model the positions along a
sequence as belonging to many different possible states, such as
&#8220;promoter&#8221;, &#8220;exon&#8221;, &#8220;intron&#8221;, and &#8220;intergenic DNA&#8221;.</p>
<p>A HMM is like having several different roulette wheels, one
roulette wheel for each state in the HMM, for example, a &#8220;GC-rich&#8221;
and an &#8220;AT-rich&#8221; roulette wheel. Each of the roulette wheels has
four slices labelled &#8220;A&#8221;, &#8220;T&#8221;, &#8220;G&#8221;, and &#8220;C&#8221;, and in each roulette
wheel a different fraction of the wheel is taken up by the four
slices. That is, the &#8220;GC-rich&#8221; and &#8220;AT-rich&#8221; roulette wheels have
different p<sub>A</sub>, p<sub>T</sub>, p<sub>G</sub> and
p<sub>C</sub> values. If we are generating a new DNA sequence
using a HMM, to decide what nucleotide to choose at a particular
sequence position, we spin the arrow of a particular roulette
wheel, and see in which slice it stops.</p>
<p>How do we decide which roulette wheel to use? Well, if there are
two roulette wheels, we tend to use the same roulette wheel that we
used to choose the previous nucleotide in the sequence, but there
is also a certain small probability of switching to the other
roulette wheel. For example, if we used the &#8220;GC-rich&#8221; roulette
wheel to choose the previous nucleotide in the sequence, there may
be a 90% chance that we will use the &#8220;GC-rich&#8221; roulette wheel again
to choose the nucleotide at the current position, but a 10% chance
that we will switch to using the &#8220;AT-rich&#8221; roulette wheel to choose
the nucleotide at the current position. Likewise, if we used the
&#8220;AT-rich&#8221; roulette wheel to choose the nucleotide at the previous
position, there may be 70% chance that we will use the &#8220;AT-rich&#8221;
wheel again at this position, but a 30% chance that we will switch
to using the &#8220;GC-rich&#8221; roulette wheel to choose the nucleotide at
this position.</p>
<p><a class="reference internal" href="../_images/P10_image6.png"><img alt="image3" src="../_images/P10_image6.png" style="width: 500px;" /></a></p>
</div>
<div class="section" id="the-transition-matrix-and-emission-matrix-for-a-hmm">
<h2>The transition matrix and emission matrix for a HMM<a class="headerlink" href="chapter10.html#the-transition-matrix-and-emission-matrix-for-a-hmm" title="Permalink to this headline">¶</a></h2>
<p>A HMM has two important matrices that hold its parameters. The
first is the <em>HMM transition matrix</em>, which contains the
probabilities of switching from one state to another. For example,
in a HMM with two states, an AT-rich state and a GC-rich state, the
transition matrix will hold the probabilities of switching from the
AT-rich state to the GC-rich state, and of switching from the
GC-rich state to the AT-rich state. For example, if the previous
nucleotide was in the AT-rich state there may be a probability of
0.3 that the current nucleotide will be in the GC-rich state, and
if the previous nucleotide was in the GC-rich state there may be a
probability of 0.1 that the current nucleotide will be in the
AT-rich state:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; states              &lt;- c(&quot;AT-rich&quot;, &quot;GC-rich&quot;) # Define the names of the states
&gt; ATrichprobs         &lt;- c(0.7, 0.3)             # Set the probabilities of switching states, where the previous state was &quot;AT-rich&quot;
&gt; GCrichprobs         &lt;- c(0.1, 0.9)             # Set the probabilities of switching states, where the previous state was &quot;GC-rich&quot;
&gt; thetransitionmatrix &lt;- matrix(c(ATrichprobs, GCrichprobs), 2, 2, byrow = TRUE) # Create a 2 x 2 matrix
&gt; rownames(thetransitionmatrix) &lt;- states
&gt; colnames(thetransitionmatrix) &lt;- states
&gt; thetransitionmatrix                            # Print out the transition matrix
AT-rich GC-rich
AT-rich     0.7     0.3
GC-rich     0.1     0.9
</pre></div>
</div>
<p>There is a row in the transition matrix for each of the possible
states at the previous position in the nucleotide sequence. For
example, in this transition matrix, the first row corresponds to
the case where the previous position was in the &#8220;AT-rich&#8221; state,
and the second row corresponds to the case where the previous
position was in the &#8220;GC-rich&#8221; state. The columns give the
probabilities of switching to different states at the current
position. For example, the value in the second row and first column
of the transition matrix above is 0.1, which is the probability of
switching to the AT-rich state, if the previous position of the
sequence was in the GC-rich state.</p>
<p>The second important matrix is the <em>HMM emission matrix</em>, which
holds the probabilities of choosing the four nucleotides &#8220;A&#8221;, &#8220;C&#8221;,
&#8220;G&#8221;, and &#8220;T&#8221;, in each of the states. In a HMM with an AT-rich state
and a GC-rich state, the emission matrix will hold the
probabilities of choosing each of the four nucleotides &#8220;A&#8221;, &#8220;C&#8221;,
&#8220;G&#8221; and &#8220;T&#8221; in the AT-rich state (for example,
p<sub>A</sub>=0.39, p<sub>C</sub>=0.1, p<sub>G</sub>=0.1, and
p<sub>T</sub>=0.41 for the AT-rich state), and the probabilities
of choosing &#8220;A&#8221;, &#8220;C&#8221;, &#8220;G&#8221;, and &#8220;T&#8221; in the GC-rich state (for
example, p<sub>A</sub>=0.1, p<sub>C</sub>=0.41,
p<sub>G</sub>=0.39, and p<sub>T</sub>=0.1 for the GC-rich
state).</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; nucleotides         &lt;- c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;)   # Define the alphabet of nucleotides
&gt; ATrichstateprobs    &lt;- c(0.39, 0.1, 0.1, 0.41) # Set the values of the probabilities, for the AT-rich state
&gt; GCrichstateprobs    &lt;- c(0.1, 0.41, 0.39, 0.1) # Set the values of the probabilities, for the GC-rich state
&gt; theemissionmatrix &lt;- matrix(c(ATrichstateprobs, GCrichstateprobs), 2, 4, byrow = TRUE) # Create a 2 x 4 matrix
&gt; rownames(theemissionmatrix) &lt;- states
&gt; colnames(theemissionmatrix) &lt;- nucleotides
&gt; theemissionmatrix                              # Print out the emission matrix
   A    C    G    T
AT-rich 0.39 0.10 0.10 0.41
GC-rich 0.10 0.41 0.39 0.10
</pre></div>
</div>
<p>There is a row in the emission matrix for each possible state, and
the columns give the probabilities of choosing each of the four
possible nucleotides when in a particular state. For example, the
value in the second row and third column of the emission matrix
above is 0.39, which is the probability of choosing a &#8220;G&#8221; when in
the &#8220;GC-rich state&#8221; (ie. when using the &#8220;GC-rich&#8221; roulette wheel).</p>
</div>
<div class="section" id="generating-a-dna-sequence-using-a-hmm">
<h2>Generating a DNA sequence using a HMM<a class="headerlink" href="chapter10.html#generating-a-dna-sequence-using-a-hmm" title="Permalink to this headline">¶</a></h2>
<p>The following function generatehmmseq() can be used to generate
a DNA sequence using a particular HMM. As its arguments (inputs), it requires the
parameters of the HMM: the HMM transmission matrix and HMM emission
matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; # Function to generate a DNA sequence, given a HMM and the length of the sequence to be generated.
  generatehmmseq &lt;- function(transitionmatrix, emissionmatrix, initialprobs, seqlength)
  {
     nucleotides     &lt;- c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;)   # Define the alphabet of nucleotides
     states          &lt;- c(&quot;AT-rich&quot;, &quot;GC-rich&quot;) # Define the names of the states
     mysequence      &lt;- character()             # Create a vector for storing the new sequence
     mystates        &lt;- character()             # Create a vector for storing the state that each position in the new sequence
                                                # was generated by
     # Choose the state for the first position in the sequence:
     firststate      &lt;- sample(states, 1, rep=TRUE, prob=initialprobs)
     # Get the probabilities of the current nucleotide, given that we are in the state &quot;firststate&quot;:
     probabilities   &lt;- emissionmatrix[firststate,]
     # Choose the nucleotide for the first position in the sequence:
     firstnucleotide &lt;- sample(nucleotides, 1, rep=TRUE, prob=probabilities)
     mysequence[1]   &lt;- firstnucleotide         # Store the nucleotide for the first position of the sequence
     mystates[1]     &lt;- firststate              # Store the state that the first position in the sequence was generated by

     for (i in 2:seqlength)
     {
        prevstate    &lt;- mystates[i-1]           # Get the state that the previous nucleotide in the sequence was generated by
        # Get the probabilities of the current state, given that the previous nucleotide was generated by state &quot;prevstate&quot;
        stateprobs   &lt;- transitionmatrix[prevstate,]
        # Choose the state for the ith position in the sequence:
        state        &lt;- sample(states, 1, rep=TRUE, prob=stateprobs)
        # Get the probabilities of the current nucleotide, given that we are in the state &quot;state&quot;:
        probabilities &lt;- emissionmatrix[state,]
        # Choose the nucleotide for the ith position in the sequence:
        nucleotide   &lt;- sample(nucleotides, 1, rep=TRUE, prob=probabilities)
        mysequence[i] &lt;- nucleotide             # Store the nucleotide for the current position of the sequence
        mystates[i]  &lt;- state                   # Store the state that the current position in the sequence was generated by
     }

     for (i in 1:length(mysequence))
     {
        nucleotide   &lt;- mysequence[i]
        state        &lt;- mystates[i]
        print(paste(&quot;Position&quot;, i, &quot;, State&quot;, state, &quot;, Nucleotide = &quot;, nucleotide))
     }
  }
</pre></div>
</div>
<p>When you are generating a DNA sequence using a HMM, the nucleotide
is chosen at each position depending on the state at the previous
position in the sequence. As there is no previous nucleotide at the
first position in the sequence, the function generatehmmseq() also
requires the probabilities of the choosing each of the states at
the first position (eg. Π<sub>AT-rich</sub> and
Π<sub>GC-rich</sub> being the probability of the choosing the
&#8220;AT-rich&#8221; or &#8220;GC-rich&#8221; states at the first position for a HMM with
these two states).</p>
<p>We can use the generatehmmseq() function to generate a sequence
using a particular HMM. For example, to create a sequence of 30
nucleotides using the HMM with &#8220;AT-rich&#8221; and &#8220;GC-rich&#8221; states
described in the transition matrix <em>thetransitionmatrix</em>, the
emission matrix <em>theemissionmatrix</em>, and uniform starting
probabilities (ie. Π<sub>AT-rich</sub> = 0.5,
Π<sub>GC-rich</sub> = 0.5), we type:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; theinitialprobs &lt;- c(0.5, 0.5)
&gt; generatehmmseq(thetransitionmatrix, theemissionmatrix, theinitialprobs, 30)
[1] &quot;Position 1 , State AT-rich , Nucleotide =  A&quot;
[1] &quot;Position 2 , State AT-rich , Nucleotide =  A&quot;
[1] &quot;Position 3 , State AT-rich , Nucleotide =  G&quot;
[1] &quot;Position 4 , State AT-rich , Nucleotide =  C&quot;
[1] &quot;Position 5 , State AT-rich , Nucleotide =  G&quot;
[1] &quot;Position 6 , State AT-rich , Nucleotide =  T&quot;
[1] &quot;Position 7 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 8 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 9 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 10 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 11 , State GC-rich , Nucleotide =  C&quot;
[1] &quot;Position 12 , State GC-rich , Nucleotide =  C&quot;
[1] &quot;Position 13 , State GC-rich , Nucleotide =  C&quot;
[1] &quot;Position 14 , State GC-rich , Nucleotide =  C&quot;
[1] &quot;Position 15 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 16 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 17 , State GC-rich , Nucleotide =  C&quot;
[1] &quot;Position 18 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 19 , State GC-rich , Nucleotide =  A&quot;
[1] &quot;Position 20 , State GC-rich , Nucleotide =  C&quot;
[1] &quot;Position 21 , State GC-rich , Nucleotide =  A&quot;
[1] &quot;Position 22 , State AT-rich , Nucleotide =  T&quot;
[1] &quot;Position 23 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 24 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 25 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 26 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 27 , State GC-rich , Nucleotide =  T&quot;
[1] &quot;Position 28 , State GC-rich , Nucleotide =  G&quot;
[1] &quot;Position 29 , State GC-rich , Nucleotide =  T&quot;
[1] &quot;Position 30 , State GC-rich , Nucleotide =  C&quot;
</pre></div>
</div>
<p>As you can see, the nucleotides generated by the GC-rich state are
mostly but not all &#8220;G&#8221;s and &#8220;C&#8221;s (because of the high values of
p<sub>G</sub> and p<sub>C</sub> for the GC-rich state in the
HMM emission matrix), while the nucleotides generated by the
AT-rich state are mostly but not all &#8220;A&#8221;s and &#8220;T&#8221;s (because of the
high values of p<sub>T</sub> and p<sub>A</sub> for the AT-rics
state in the HMM emission matrix).</p>
<p>Furthermore, there tends to be runs of nucleotides that are either
all in the GC-rich state or all in the AT-rich state, as the
transition matrix specifies that the probabilities of switching
from the AT-rich to GC-rich state (probability 0.3), or GC-rich to
AT-rich state (probability 0.1) are relatively low.</p>
</div>
<div class="section" id="inferring-the-states-of-a-hmm-that-generated-a-dna-sequence">
<h2>Inferring the states of a HMM that generated a DNA sequence<a class="headerlink" href="chapter10.html#inferring-the-states-of-a-hmm-that-generated-a-dna-sequence" title="Permalink to this headline">¶</a></h2>
<p>If we have a HMM with two states, &#8220;GC-rich&#8221; and &#8220;AT-rich&#8221;, and we
know the transmission and emission matrices of the HMM, can we take
some new DNA sequence, and figure out which state (GC-rich or
AT-rich) is the most likely to have generated each nucleotide
position in that DNA sequence? This is a common problem in
bioinformatics. It is called the problem of finding the
<em>most probable state path</em>, as it essentially consists of assigning
the most likely state to each position in the DNA sequence. The
problem of finding the most probable state path is also sometimes
called <em>segmentation</em>. For example, give a DNA sequence of 1000
nucleotides, you may wish to use your HMM to <em>segment</em> the sequence
into blocks that were probably generated by the &#8220;GC-rich&#8221; state or
by the &#8220;AT-rich&#8221; state.</p>
<p>The problem of finding the most probable state path given a HMM and
a sequence (ie. the problem of <em>segmenting</em> a sequence using a
HMM), can be solved by an algorithm called the <em>Viterbi algorithm</em>.
As its output, the Viterbi algorithm gives for each nucleotide
position in a DNA sequence, the state of your HMM that most
probably generated the nucleotide in that position. For example, if
you segmented a particular DNA sequence of 1000 nucleotides using a
HMM with &#8220;AT-rich&#8221; and &#8220;GC-rich&#8221; states, the Viterbi algorithm may
tell you that nucleotides 1-343 were most probably generated by the
AT-rich state, nucleotides 344-900 were most probably generated by
the GC-rich state, and 901-1000 were most probably generated by the
AT-rich state.</p>
<p>The following function viterbi() is a function for the Viterbi algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; viterbi &lt;- function(sequence, transitionmatrix, emissionmatrix)
  # This carries out the Viterbi algorithm.
  # Adapted from &quot;Applied Statistics for Bioinformatics using R&quot; by Wim P. Krijnen, page 209
  # ( cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf )
  {
     # Get the names of the states in the HMM:
     states &lt;- rownames(theemissionmatrix)

     # Make the Viterbi matrix v:
     v &lt;- makeViterbimat(sequence, transitionmatrix, emissionmatrix)

     # Go through each of the rows of the matrix v (where each row represents
     # a position in the DNA sequence), and find out which column has the
     # maximum value for that row (where each column represents one state of
     # the HMM):
     mostprobablestatepath &lt;- apply(v, 1, function(x) which.max(x))

     # Print out the most probable state path:
     prevnucleotide &lt;- sequence[1]
     prevmostprobablestate &lt;- mostprobablestatepath[1]
     prevmostprobablestatename &lt;- states[prevmostprobablestate]
     startpos &lt;- 1
     for (i in 2:length(sequence))
     {
        nucleotide &lt;- sequence[i]
        mostprobablestate &lt;- mostprobablestatepath[i]
        mostprobablestatename &lt;- states[mostprobablestate]
        if (mostprobablestatename != prevmostprobablestatename)
        {
           print(paste(&quot;Positions&quot;,startpos,&quot;-&quot;,(i-1), &quot;Most probable state = &quot;, prevmostprobablestatename))
           startpos &lt;- i
        }
        prevnucleotide &lt;- nucleotide
        prevmostprobablestatename &lt;- mostprobablestatename
     }
     print(paste(&quot;Positions&quot;,startpos,&quot;-&quot;,i, &quot;Most probable state = &quot;, prevmostprobablestatename))
   }
</pre></div>
</div>
<p>The viterbi() function requires a second function makeViterbimat():</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; makeViterbimat &lt;- function(sequence, transitionmatrix, emissionmatrix)
  # This makes the matrix v using the Viterbi algorithm.
  # Adapted from &quot;Applied Statistics for Bioinformatics using R&quot; by Wim P. Krijnen, page 209
  # ( cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf )
  {
     # Change the sequence to uppercase
     sequence &lt;- toupper(sequence)
     # Find out how many states are in the HMM
     numstates &lt;- dim(transitionmatrix)[1]
     # Make a matrix with as many rows as positions in the sequence, and as many
     # columns as states in the HMM
     v &lt;- matrix(NA, nrow = length(sequence), ncol = dim(transitionmatrix)[1])
     # Set the values in the first row of matrix v (representing the first position of the sequence) to 0
     v[1, ] &lt;- 0
     # Set the value in the first row of matrix v, first column to 1
     v[1,1] &lt;- 1
     # Fill in the matrix v:
     for (i in 2:length(sequence)) # For each position in the DNA sequence:
     {
        for (l in 1:numstates) # For each of the states of in the HMM:
        {
           # Find the probabilility, if we are in state l, of choosing the nucleotide at position in the sequence
           statelprobnucleotidei &lt;- emissionmatrix[l,sequence[i]]

           # v[(i-1),] gives the values of v for the (i-1)th row of v, ie. the (i-1)th position in the sequence.
           # In v[(i-1),] there are values of v at the (i-1)th row of the sequence for each possible state k.
           # v[(i-1),k] gives the value of v at the (i-1)th row of the sequence for a particular state k.

           # transitionmatrix[l,] gives the values in the lth row of the transition matrix, xx should not be transitionmatrix[,l]?
           # probabilities of changing from a previous state k to a current state l.

           # max(v[(i-1),] * transitionmatrix[l,]) is the maximum probability for the nucleotide observed
           # at the previous position in the sequence in state k, followed by a transition from previous
           # state k to current state l at the current nucleotide position.

           # Set the value in matrix v for row i (nucleotide position i), column l (state l) to be:
           v[i,l] &lt;-  statelprobnucleotidei * max(v[(i-1),] * transitionmatrix[,l])
        }
    }
    return(v)
  }
</pre></div>
</div>
<p>Given a HMM, and a particular DNA sequence, you can use the Viterbi function to find the state of
that HMM that was most likely to have generated the nucleotide at
each position in the DNA sequence:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt; myseq &lt;- c(&quot;A&quot;, &quot;A&quot;, &quot;G&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;, &quot;G&quot;, &quot;G&quot;, &quot;G&quot;, &quot;G&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;G&quot;, &quot;G&quot;, &quot;C&quot;, &quot;G&quot;, &quot;A&quot;, &quot;C&quot;, &quot;A&quot;, &quot;T&quot;, &quot;G&quot;, &quot;G&quot;, &quot;G&quot;, &quot;G&quot;, &quot;T&quot;, &quot;G&quot;, &quot;T&quot;, &quot;C&quot;)
&gt; viterbi(myseq, thetransitionmatrix, theemissionmatrix)
[1] &quot;Positions 1 - 2 Most probable state =  AT-rich&quot;
[1] &quot;Positions 3 - 21 Most probable state =  GC-rich&quot;
[1] &quot;Positions 22 - 22 Most probable state =  AT-rich&quot;
[1] &quot;Positions 23 - 23 Most probable state =  GC-rich&quot;
</pre></div>
</div>
</div>
<div class="section" id="a-hidden-markov-model-of-protein-sequence-evolution">
<h2>A Hidden Markov Model of protein sequence evolution<a class="headerlink" href="chapter10.html#a-hidden-markov-model-of-protein-sequence-evolution" title="Permalink to this headline">¶</a></h2>
<p>We have so far talked about using HMMs to model DNA sequence
evolution. However, it is of course possible to use HMMs to model
protein sequence evolution. When using a HMM to model DNA sequence
evolution, we may have states such as &#8220;AT-rich&#8221; and &#8220;GC-rich&#8221;.
Similarly, when using a HMM to model protein sequence evolution, we
may have states such as &#8220;hydrophobic&#8221; and &#8220;hydrophilic&#8221;. In a
protein HMM with &#8220;hydrophilic&#8221; and &#8220;hydrophilic&#8221; states, the
&#8220;hydrophilic&#8221; HMM will have probabilities p<sub>A</sub>,
p<sub>R</sub>, p<sub>C</sub>... of choosing each of the 20
amino acids alanine (A), arginine (R), cysteine (C), etc. when in
that state. Similarly, the &#8220;hydrophilic&#8221; state will have different
probabilities p<sub>A</sub>, p<sub>R</sub>, p<sub>C</sub>...
of choosing each of the 20 amino acids. The probability of choosing
a hydrophobic amino acid such as alanine will be higher in the
&#8220;hydrophobic&#8221; state than in the &#8220;hydrophilic&#8221; state (ie.
p<sub>A</sub> of the &#8220;hydrophobic&#8221; state will be higher than the
p<sub>A</sub> of of the &#8220;hydrophilic&#8221; state, where A represents
alanine here). A HMM of protein sequence evolution also defines a
certain probability of switching from the &#8220;hydrophilic&#8221; state to
the &#8220;hydrophobic&#8221; state, and a certain probability of switching
from the &#8220;hydrophobic&#8221; state to the &#8220;hydrophilic&#8221; state.</p>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="chapter10.html#summary" title="Permalink to this headline">¶</a></h2>
<p>In this practical, you will have learnt to use the following R
functions:</p>
<ol class="arabic simple">
<li>numeric() for making a vector for storing numbers</li>
<li>character() for making a vector for storing characters</li>
<li>matrix() for making a matrix variable</li>
<li>rownames() for assigning names to the rows of a matrix variable</li>
<li>colnames() for assigning names to the columns of a matrix
variable</li>
<li>sample() for making a random sample of numbers from a vector of
numbers</li>
</ol>
<p>All of these functions belong to the standard installation of R.</p>
</div>
<div class="section" id="links-and-further-reading">
<h2>Links and Further Reading<a class="headerlink" href="chapter10.html#links-and-further-reading" title="Permalink to this headline">¶</a></h2>
<p>Some links are included here for further reading, which will be
especially useful if you need to use the R package for your project
or assignments.</p>
<p>For background reading on multinomial models, Markov models, and
HMMs, it is recommended to read Chapters 1 and 4 of
<em>Introduction to Computational Genomics: a case studies approach</em>
by Cristianini and Hahn (Cambridge University Press;
<a class="reference external" href="http://www.computational-genomics.net/book/">www.computational-genomics.net/book/</a>).</p>
<p>There is also a very nice chapter on &#8220;Markov Models&#8221; in the book
<em>Applied statistics for bioinformatics using R</em> by Krijnen
(available online at
<a class="reference external" href="http://cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf">cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf</a>).</p>
</div>
<div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="chapter10.html#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>Many of the ideas for the examples and exercises for this practical
were inspired by the Matlab case studies on the Bacteriophage
lambda genome
(<a class="reference external" href="http://www.computational-genomics.net/case_studies//lambdaphage_demo.html">www.computational-genomics.net/case_studies//lambdaphage_demo.html</a>)
and on the olfactory receptors
(<a class="reference external" href="http://www.computational-genomics.net/case_studies/olfactoryreceptors_demo.html">www.computational-genomics.net/case_studies/olfactoryreceptors_demo.html</a>)
from the website that accompanies the book
<em>Introduction to Computational Genomics: a case studies approach</em>
by Cristianini and Hahn (Cambridge University Press;
<a class="reference external" href="http://www.computational-genomics.net/book/">www.computational-genomics.net/book/</a>).</p>
<p>Several of the examples and and sample code used in this practical
were inspired by the examples and code in the great chapter on
&#8220;Markov models&#8221; in the book
<em>Applied statistics for bioinformatics using R</em> by Krijnen
(available online at
<a class="reference external" href="http://cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf">cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf</a>).</p>
<p>Thank you to Noel O&#8217;Boyle for his nice suggestion of using roulette
wheels to explain multinomial models, Markov models and HMMs.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="chapter10.html#exercises" title="Permalink to this headline">¶</a></h2>
<p>Answer the following questions, using the R package. For each
question, please record your answer, and what you typed into R to
get this answer.</p>
<dl class="docutils">
<dt>Q1. In a previous practical, you saw that the Bacteriophage lambda genome sequence (NCBI accession NC_001416) has</dt>
<dd><p class="first">long stretches of either very GC-rich (mostly in the first half of the genome) or very AT-rich sequence
(mostly in the second half of the genome). Use a HMM with two different states (&#8220;AT-rich&#8221; and &#8220;GC-rich&#8221;) to
infer which state of the HMM is most likely to have generated each nucleotide position in the Bacteriophage
lambda genome sequence. For the AT-rich state, set p<sub>A</sub>= 0.27, p<sub>C</sub>= 0.2084,
p<sub>G</sub>= 0.198, and p<sub>T</sub>= 0.3236. For the GC-rich state, set p<sub>A</sub>= 0.2462,
p<sub>C</sub>= 0.2476, p<sub>G</sub>= 0.2985, and p<sub>T</sub>= 0.2077.
Set the probability of switching from the AT-rich state to the GC-rich state to be 0.0002, and the</p>
<blockquote class="last">
<div>probability of switching from the GC-rich state to the AT-rich state to be 0.0002.
What is the most probable state path?</div></blockquote>
</dd>
<dt>Q2. Given a HMM with four different states (&#8220;A-rich&#8221;, &#8220;C-rich&#8221;, &#8220;G-rich&#8221; and &#8220;T-rich&#8221;), infer which state of</dt>
<dd>the HMM is most likely to have generated each nucleotide position in the Bacteriophage lambda genome sequence.
For the A-rich state, set p<sub>A</sub>= 0.3236, p<sub>C</sub>= 0.2084, p<sub>G</sub>= 0.198, and
p<sub>T</sub>= 0.27. For the C-rich state, set p<sub>A</sub>= 0.2462, p<sub>C</sub>= 0.2985,
p<sub>G</sub>= 0.2476, and p<sub>T</sub>= 0.2077. For the G-rich state, set p<sub>A</sub>= 0.2462,
p<sub>C</sub>= 0.2476, p<sub>G</sub>= 0.2985, and p<sub>T</sub>= 0.2077. For the T-rich state,
set p<sub>A</sub>= 0.27, p<sub>C</sub>= 0.2084, p<sub>G</sub>= 0.198, and p<sub>T</sub>= 0.3236.
Set the probability of switching from the A-rich state to any of the three other states to be
6.666667e-05. Likewise, set the probability of switching from the C-rich/G-rich/T-rich state to any
of the three other states to be 6.666667e-05.
What is the most probable state path?
Do you find differences between these results and the results from
simply using a two-state HMM (as in Q1)?</dd>
<dt>Q3. Make a two-state HMM to model protein sequence evolution, with &#8220;hydrophilic&#8221; and &#8220;hydrophobic&#8221; states.</dt>
<dd>For the hydrophilic state, set p<sub>A</sub>= 0.02, p<sub>R</sub>= 0.068, p<sub>N</sub>= 0.068,
p<sub>D</sub>= 0.068, p<sub>C</sub>= 0.02, p<sub>Q</sub>= 0.068, p<sub>E</sub>= 0.068, p<sub>G</sub>= 0.068,
p<sub>H</sub>= 0.068, p<sub>I</sub>= 0.012, p<sub>L</sub>= 0.012, p<sub>K</sub>= 0.068, p<sub>M</sub>= 0.02,
p<sub>F</sub>= 0.02, p<sub>P</sub>= 0.068, p<sub>S</sub>= 0.068, p<sub>T</sub>= 0.068, p<sub>W</sub>= 0.068,
p<sub>Y</sub>= 0.068, and p<sub>V</sub>= 0.012. For the hydrophobic state, set p<sub>A</sub>= 0.114,
p<sub>R</sub>= 0.007, p<sub>N</sub>= 0.007, p<sub>D</sub>= 0.007, p<sub>C</sub>= 0.114, p<sub>Q</sub>= 0.007,
p<sub>E</sub>= 0.007, p<sub>G</sub>= 0.025, p<sub>H</sub>= 0.007, p<sub>I</sub>= 0.114, p<sub>L</sub>= 0.114,
p<sub>K</sub>= 0.007, p<sub>M</sub>= 0.114, p<sub>F</sub>= 0.114, p<sub>P</sub>= 0.025, p<sub>S</sub>= 0.026,
p<sub>T</sub>= 0.026, p<sub>W</sub>= 0.025, p<sub>Y</sub>= 0.026, and p<sub>V</sub>= 0.114.
Set the probability of switching from the hydrophilic state to the hydrophobic state to be 0.01.
Set the probability of switching from the hydrophobic state to the hydrophilic state to be 0.01.
Now infer which state of the HMM is most likely to have generated each amino acid position in the the
human odorant receptor 5BF1 protein (UniProt accession Q8NHC7).
What is the most probable state path?
The odorant receptor is a 7-transmembrane protein, meaning that it
crosses the cell membrane seven times. As a consequence the protein
has seven hydrophobic regions that cross the fatty cell membrane,
and seven hydrophilic segments that touch the watery cytoplasm and
extracellular environments. What do you think are the coordinates
in the protein of the seven transmembrane regions?</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chapter_answers.html" title="Answers to the End-of-chapter Exercises"
             >next</a> |</li>
        <li class="right" >
          <a href="chapter9.html" title="Comparative Genomics"
             >previous</a> |</li>
        <li><a href="https://a-little-book-of-r-for-bioinformatics.readthedocs.org/en/latest/index.html">Bioinformatics 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Avril Coghlan, Licence: Creative Commons Attribution 3.0 License.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>